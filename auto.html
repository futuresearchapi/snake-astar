<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Blue Snake AI - Max Length AI</title>
<style>
    body { display:flex; flex-direction:column; align-items:center; background:#222; font-family:Arial; color:#fff; margin:0; padding:20px;}
    canvas { background:#111; border:3px solid #00f; border-radius:8px; margin:20px 0;}
    h1 { margin:10px 0;}
    label, button, input { margin:10px; font-size:1.2em;}
    button { padding:8px 16px; cursor:pointer; background:#00f; color:#fff; border:none; border-radius:5px;}
    button:hover { background:#0055ff;}
    input { width:60px; }
    #overlay {
        position:absolute; top:0; left:0; width:100%; height:100%;
        background:rgba(0,0,0,0.8); color:white; font-size:48px;
        display:flex; justify-content:center; align-items:center;
        z-index:10; flex-direction:column; display:none;
    }
</style>
</head>
<body>
<h1>Blue Snake AI</h1>
<label><input type="checkbox" id="useAI"> Use AI</label>
<label><input type="checkbox" id="showPath"> Show AI Path</label>
<br>
<label>Map Size: <input type="number" id="mapSizeInput" value="15" min="5" max="50"></label>
<label>Apples: <input type="number" id="appleCountInput" value="5" min="1" max="20"></label>
<canvas id="snake" width="480" height="480"></canvas>
<h1>Score: <span id="score">0</span></h1>
<button id="playAgain">Play Again</button>

<div id="overlay">
    <div id="overlayText"></div>
    <button onclick="initGame()">Play Again</button>
</div>

<script>
const cvs = document.getElementById("snake");
const ctx = cvs.getContext("2d");
let box = 32;
let gridSize = parseInt(document.getElementById("mapSizeInput").value);
let appleCount = parseInt(document.getElementById("appleCountInput").value);

let snake, foods, score, d, game;
let useAI = document.getElementById("useAI");
let showPath = document.getElementById("showPath");

let dead = new Audio("/sound/gameover.mp3");
let eat = new Audio("/sound/eated.mp3");
let overlay = document.getElementById("overlay");
let overlayText = document.getElementById("overlayText");

// ---------------- Initialize Game ----------------
function initGame() {
    gridSize = parseInt(document.getElementById("mapSizeInput").value);
    appleCount = parseInt(document.getElementById("appleCountInput").value);
    cvs.width = cvs.height = gridSize * box;

    snake = [{x: Math.floor(gridSize/2)*box, y: Math.floor(gridSize/2)*box}];
    score = 0;
    d = "RIGHT";

    foods = [];
    for(let i=0;i<appleCount;i++) foods.push(spawnFood());

    overlay.style.display = "none";

    if(game) clearInterval(game);
    game = setInterval(draw, 120);
}

// ---------------- Spawn Food ----------------
function spawnFood() {
    let f;
    do {
        f = {x: Math.floor(Math.random()*gridSize)*box, y: Math.floor(Math.random()*gridSize)*box};
    } while(snake.some(seg => seg.x===f.x && seg.y===f.y) || foods?.some(fd => fd.x===f.x && fd.y===f.y));
    return f;
}

// ---------------- Collision ----------------
function collision(head, array){
    return array.some(seg => seg.x===head.x && seg.y===head.y);
}

// ---------------- Heuristic for A* ----------------
function heuristic(a, b) {
    return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
}

// ---------------- Hybrid Pathfinding (A* + BFS) ----------------
function hybridPath(start, target, snakeBody) {
    // A* implementation
    const directions = [
        {name:"UP", dx:0, dy:-1},
        {name:"DOWN", dx:0, dy:1},
        {name:"LEFT", dx:-1, dy:0},
        {name:"RIGHT", dx:1, dy:0}
    ];

    // Priority queue for A*
    let openSet = [];
    let cameFrom = {};
    let gScore = {};
    let fScore = {};

    function key(pos) { return pos.x + "," + pos.y; }

    gScore[key(start)] = 0;
    fScore[key(start)] = heuristic(start, target);
    openSet.push({pos: start, f: fScore[key(start)]});

    const snakeSet = new Set(snakeBody.map(seg => key(seg)));

    while (openSet.length > 0) {
        // get node with lowest f
        openSet.sort((a, b) => a.f - b.f);
        const current = openSet.shift().pos;

        if (current.x === target.x && current.y === target.y) {
            // reconstruct path
            let path = [];
            let c = key(current);
            while(c !== key(start)){
                let prev = cameFrom[c];
                let moveDir = "";
                if(prev.x === current.x && prev.y - current.y === -box) moveDir="UP";
                else if(prev.x === current.x && prev.y - current.y === box) moveDir="DOWN";
                else if(prev.x - current.x === box && prev.y === current.y) moveDir="LEFT";
                else if(prev.x - current.x === -box && prev.y === current.y) moveDir="RIGHT";
                path.unshift(moveDir);
                current.x = prev.x;
                current.y = prev.y;
                c = key(prev);
            }
            return path;
        }

        for(let dir of directions){
            let neighborX = current.x + dir.dx*box;
            let neighborY = current.y + dir.dy*box;
            if(neighborX<0 || neighborX>=gridSize*box || neighborY<0 || neighborY>=gridSize*box) continue;
            // ignore if it's snake body except current position
            if(snakeSet.has(neighborX+","+neighborY) && !(neighborX===target.x && neighborY===target.y)) continue;
            let tentative_gScore = gScore[key(current)] + 1;
            if(tentative_gScore < (gScore[key({x: neighborX, y: neighborY})]] || Infinity)){
                cameFrom[key({x: neighborX, y: neighborY})]] = {x: current.x, y: current.y};
                gScore[key({x: neighborX, y: neighborY})]] = tentative_gScore;
                fScore[key({x: neighborX, y: neighborY})]] = tentative_gScore + heuristic({x: neighborX, y: neighborY}, target);
                if(!openSet.some(n => key(n.pos)===key({x: neighborX, y: neighborY}))){
                    openSet.push({pos: {x: neighborX, y: neighborY}, f: fScore[key({x: neighborX, y: neighborY})]]});
                }
            }
        }
    }

    // BFS fallback if A* fails
    const queue = [{x:start.x, y:start.y, path:[]}];
    const visited = new Set();
    visited.add(key(start));
    const bodySet = new Set(snakeBody.map(seg=>seg.x+","+seg.y));

    while(queue.length>0){
        const node = queue.shift();
        if(node.x===target.x && node.y===target.y) return node.path;
        for(let dir of directions){
            let nx = node.x + dir.dx*box;
            let ny = node.y + dir.dy*box;
            if(nx<0 || nx>=gridSize*box || ny<0 || ny>=gridSize*box) continue;
            if(bodySet.has(nx+","+ny) && !(nx===target.x && ny===target.y)) continue;
            if(visited.has(nx+","+ny)) continue;
            visited.add(nx+","+ny);
            queue.push({x:nx, y:ny, path: node.path.concat(dir.name)});
        }
    }
    return [];
}

// ---------------- Flood Fill ----------------
function floodFill(x, y, snakeBody){
    let visited = {};
    let queue = [{x,y}];
    let count = 0;
    function key(pos){ return pos.x+","+pos.y; }
    while(queue.length){
        let pos = queue.shift();
        if(pos.x<0 || pos.x>=gridSize*box || pos.y<0 || pos.y>=gridSize*box) continue;
        if(visited[key(pos)]) continue;
        if(snakeBody.some(seg=>seg.x===pos.x && seg.y===pos.y)) continue;
        visited[key(pos)] = true;
        count++;
        queue.push({x:pos.x+box, y:pos.y});
        queue.push({x:pos.x-box, y:pos.y});
        queue.push({x:pos.x, y:pos.y+box});
        queue.push({x:pos.x, y:pos.y-box});
    }
    return count;
}

// ---------------- Determine AI Move ----------------
function getAIMove(){
    if(!useAI.checked) return d;

    let bestApple = foods[0];
    let bestScore = -Infinity;
    let bestPath = [];

    for(let f of foods){
        const path = hybridPath(snake[0], f, snake);
        if(path.length===0) continue;

        // Simulate moving along path and then follow tail loop if necessary
        let simSnake = snake.map(seg=>({...seg}));
        let tempHead = {...simSnake[0]};
        path.forEach(move=>{
            if(move==="UP") tempHead.y-=box;
            if(move==="DOWN") tempHead.y+=box;
            if(move==="LEFT") tempHead.x-=box;
            if(move==="RIGHT") tempHead.x+=box;
            simSnake.unshift({...tempHead});
            simSnake.pop();
        });

        // After reaching apple, simulate free space if following tail loop
        let freeSpace = floodFill(tempHead.x, tempHead.y, simSnake);
        if(freeSpace > bestScore){
            bestScore = freeSpace;
            bestApple = f;
            bestPath = path;
        }
    }

    if(showPath.checked){
        ctx.fillStyle="rgba(0,200,255,0.5)";
        let pos = {...snake[0]};
        bestPath.forEach(move=>{
            if(move==="UP") pos.y-=box;
            if(move==="DOWN") pos.y+=box;
            if(move==="LEFT") pos.x-=box;
            if(move==="RIGHT") pos.x+=box;
            ctx.fillRect(pos.x+8,pos.y+8,box-16,box-16);
        });
    }

    return bestPath[0] || d;
}

// ---------------- Manual control ----------------
document.addEventListener("keydown", function(event){
    if(useAI.checked) return; // ignore manual input when AI is on
    if(event.key === "ArrowUp" && d !== "DOWN") d = "UP";
    if(event.key === "ArrowDown" && d !== "UP") d = "DOWN";
    if(event.key === "ArrowLeft" && d !== "RIGHT") d = "LEFT";
    if(event.key === "ArrowRight" && d !== "LEFT") d = "RIGHT";
});

// ---------------- Draw ----------------
function draw(){
    ctx.fillStyle="#111";
    ctx.fillRect(0,0,cvs.width,cvs.height);

    snake.forEach((seg,i)=>{
        ctx.fillStyle = i===0 ? "blue" : "lightblue";
        ctx.fillRect(seg.x,seg.y,box,box);
        ctx.strokeStyle="darkblue";
        ctx.strokeRect(seg.x,seg.y,box,box);
    });

    foods.forEach(f=>{ ctx.fillStyle="red"; ctx.fillRect(f.x,f.y,box,box); });

    if(useAI.checked) d = getAIMove();

    let snakeX = snake[0].x;
    let snakeY = snake[0].y;
    if(d==="UP") snakeY-=box;
    if(d==="DOWN") snakeY+=box;
    if(d==="LEFT") snakeX-=box;
    if(d==="RIGHT") snakeX+=box;

    let newHead = {x:snakeX, y:snakeY};

    // Eat food
    for(let i=0;i<foods.length;i++){
        if(newHead.x===foods[i].x && newHead.y===foods[i].y){
            score++;
            eat.play();
            foods[i] = spawnFood();
            snake.push({...snake[snake.length-1]}); // grow
        }
    }

    if(snakeX<0 || snakeX>=gridSize*box || snakeY<0 || snakeY>=gridSize*box || collision(newHead, snake)){
        clearInterval(game);
        dead.play();
        overlayText.textContent = "You Died!";
        overlay.style.display = "flex";
        return;
    }

    snake.unshift(newHead);
    snake.pop();
    document.getElementById("score").textContent = score;

    // Win condition: snake fills grid (all space occupied)
    if(snake.length >= gridSize*gridSize){
        clearInterval(game);
        overlayText.textContent = "You Won!";
        overlay.style.display = "flex";
        return;
    }
}

// ---------------- Play Again ----------------
document.getElementById("playAgain").addEventListener("click", initGame);

// ---------------- Start Game ----------------
initGame();
</script>
</body>
</html>
